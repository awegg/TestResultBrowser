@using System.Collections.Generic
@using MudBlazor

<MudPaper Class="pa-2" Style="background:white; border-radius:4px; max-width:800px; width:95%; max-height:80vh; display:flex; flex-direction:column;">
    <div class="d-flex align-center justify-space-between" style="padding:8px 12px; border-bottom:1px solid #eee;">
        <MudText Typo="Typo.h6">Select Teams & Features</MudText>
        <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="@(() => OnCancel.InvokeAsync())" />
    </div>

    <div style="padding:12px;">
        <MudTextField @bind-Value="searchText"
                      Placeholder="Search teams or features..."
                      Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Filled.Search"
                      Variant="Variant.Outlined"
                      Immediate="true"
                      Dense="true"
                      FullWidth="true" />
    </div>

    <div style="padding:0 12px; flex:1; overflow:auto;">
        <MudExpansionPanels Dense="true">
            @foreach (var group in GetFilteredGroups())
            {
                var groupName = group.Key;
                var features = group.Value;
                var allSelected = features.All(IsFeatureSelected);
                var anySelected = features.Any(IsFeatureSelected);
                var groupChanged = CreateGroupChangedCallback(groupName);
                <MudExpansionPanel IsExpanded="@IsGroupExpanded(groupName)">
                    <TitleContent>
                        <div class="d-flex align-center" style="gap:8px;">
                            <MudCheckBox T="bool?" TriState="true"
                                         Checked="@(allSelected ? true : anySelected ? (bool?)null : false)"
                                         Indeterminate="@(!allSelected && anySelected)"
                                         CheckedChanged="@groupChanged" />
                            <MudText Typo="Typo.subtitle2">@groupName</MudText>
                        </div>
                    </TitleContent>
                    <ChildContent>
                        @foreach (var feature in features)
                        {
                            var featureChanged = CreateFeatureChangedCallback(feature);
                            <div class="d-flex align-center" style="gap:8px; padding:4px 0;">
                                <MudCheckBox T="bool"
                                             Checked="@IsFeatureSelected(feature)"
                                             CheckedChanged="@featureChanged" />
                                <MudText>@feature</MudText>
                            </div>
                        }
                    </ChildContent>
                </MudExpansionPanel>
            }
        </MudExpansionPanels>
    </div>

    <div class="d-flex" style="gap:8px; padding:12px; border-top:1px solid #eee; justify-content:flex-end;">
        <MudButton Variant="Variant.Outlined" Color="Color.Info" OnClick="@ClearAll">Clear All</MudButton>
        <MudButton Variant="Variant.Outlined" OnClick="@(() => OnCancel.InvokeAsync())">Cancel</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@Apply">Apply</MudButton>
    </div>
</MudPaper>

@code {
    [Parameter]
    public Dictionary<string, List<string>> FeatureGroups { get; set; } = new();

    [Parameter]
    public HashSet<string> SelectedFeatures { get; set; } = new();

    [Parameter]
    public EventCallback<HashSet<string>> OnApply { get; set; }

    [Parameter]
    public EventCallback OnCancel { get; set; }

    private string searchText = string.Empty;
    private HashSet<string> tempSelected = new();
    private Dictionary<string, bool> expanded = new();

    protected override void OnInitialized()
    {
        SyncSelections();
    }

    protected override void OnParametersSet()
    {
        SyncSelections();
    }

    private bool IsGroupExpanded(string group) => expanded.TryGetValue(group, out var v) ? v : false;

    private void SyncSelections()
    {
        tempSelected = new HashSet<string>(SelectedFeatures);
        foreach (var g in FeatureGroups.Keys)
        {
            if (!expanded.ContainsKey(g)) expanded[g] = true;
        }
    }

    private void ToggleGroup(string group, bool select)
    {
        if (!FeatureGroups.TryGetValue(group, out var features)) return;
        foreach (var f in features)
        {
            if (select) tempSelected.Add(f);
            else tempSelected.Remove(f);
        }
        StateHasChanged();
    }

    private void ToggleFeature(string feature, bool select)
    {
        if (select) tempSelected.Add(feature);
        else tempSelected.Remove(feature);
        StateHasChanged();
    }

    private void OnGroupChanged(string group, bool? value)
    {
        var select = value == true;
        ToggleGroup(group, select);
    }

    private void OnFeatureChanged(string feature, bool value)
    {
        ToggleFeature(feature, value);
    }

    private bool IsFeatureSelected(string feature) => tempSelected.Contains(feature);

    private EventCallback<bool?> CreateGroupChangedCallback(string groupName)
    {
        return EventCallback.Factory.Create<bool?>(this, (bool? value) => OnGroupChanged(groupName, value));
    }

    private EventCallback<bool> CreateFeatureChangedCallback(string feature)
    {
        return EventCallback.Factory.Create<bool>(this, (bool value) => OnFeatureChanged(feature, value));
    }

    private void ClearAll()
    {
        tempSelected.Clear();
        StateHasChanged();
    }

    private async Task Apply()
    {
        await OnApply.InvokeAsync(new HashSet<string>(tempSelected));
    }

    private IEnumerable<KeyValuePair<string, List<string>>> GetFilteredGroups()
    {
        var q = (searchText ?? string.Empty).Trim();
        var groups = FeatureGroups
            .OrderBy(kv => kv.Key)
            .Select(kv => new KeyValuePair<string, List<string>>(kv.Key, kv.Value.OrderBy(v => v).ToList()));
        if (string.IsNullOrEmpty(q)) return groups;
        return groups
            .Select(kv => new KeyValuePair<string, List<string>>(kv.Key, kv.Value.Where(v => v.Contains(q, StringComparison.OrdinalIgnoreCase)).ToList()))
            .Where(kv => kv.Value.Any());
    }
}
